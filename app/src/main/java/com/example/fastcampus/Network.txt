네트워크의 흐름
step 1) 클라이언트(앱) -> (인터넷) -> 서버 : 요청(내가 지금 첫 화면을 그리려고 하는데 데이터좀 줘)
step 2) 서버 -> (인터넷) -> 클라이언트(앱) : 응답(화면을 그릴 수 있는 데이터가 도착)
클라이언트의 request 에 서버가 response 를 보낸다.
대부분의 앱들은 네트워크 작업이 필요함

네트워크의 문제점?
매번 똑같은 UI를 그리는 경우 매번 서버에게 요청을 하는 방식은 매우 비효율적이다. 이때는 캐싱(caching) 방식이 필요하다.
캐싱(caching)은 한번 받은 데이터는 클라이언트가 로컬 데이터베이스(sharedpreference, room 등)에 저장한다.
다시 필요한 경우 서버에 요청하는 것이 아니라 로컬 데이터베이스의 데이터를 이용한다.
캐싱(caching)은 구현 난이도가 높다.

네트워킹: 서버(response)와 클라이언트(request)의 의사소통
의사소통을 하는데는 약속이 필요한데, 이때 약속을 프로토콜(protocol)이라고 한다.

네트워크 프로토콜(규약)

네트워크도 목적에 따라서 종류가 많다.
FTP -> 파일 전송을 위한 규약. = 파일을 전송할때는 해당 규약을 지켜야한다.
SMTP -> 메일 전송 규약
HTTP -> 인터넷 서비스를 위한 규약(때표적)
관련 공부를 더 하고 싶으면 학교 2학년 과목 중 ‘컴퓨터 네트워크’ 부분 참고하는 것도 좋을 듯

HTTP 프로토콜(규약)로 Request 하는 법 (클라이언트 -> 서버)
Request Headers : 요청에 대한 추가 정보
서버 개발자들이 “헤더에 이런 정보를 실어주세요~” 라고 요청하는 경우가 있음
Request Body : 요청받고 싶은 데이터에 대한 조건을 명시할 수 있음(추가정보), Json 형태 / raw
{ “id” : 1 }
Request Method(대표적으로 HTTP 요청 메소드) -> 독단적으로 해당 명령어로 서버에 요청할 수는 없다.  서버도 해당 요청을 받을 준비가 되있어야만 특정 명령어를 사용할 수 있다.
GET : “나 ~ 정보 줘!” -> 데이터 정보 요청
POST : 유저 정보를 데이터베이스에 등록시켜줘! -> JSON 형태로 등록할 데이터를 전달해야함. ex) { “name” : “홍길동”, “age” : 10 }
PUT : 저 유저를 홍길동 10살로 저장했는데 김아무개 12살로 바꿔줘! (모든 데이터 변경)
PATCH : 홍길동 12살로 바꿔줘! (데이터 중 일부만 변경됨. 전체가 변경되는 것이 아님) -> 하지만, PUT과 PATCH를 구별하지 않고 사용하는 경우도 있음
DELETE : 데이터베이스에서 특정 데이터를 삭제하고 싶은 경우 ex) id = 1 인 학생 정보를 지워줘.
CONNECT

Response 프로토콜 (서버 -> 클라이언트)
Response Code : 응답에 대한 요약
Status
2xx : 성공
200: 너가 요청한 데이터 잘 왔어
201: 너가 요청한 데이터를 데이터베이스에 잘 등록했어~
4xx : 요청 오류
401: 너 그 데이터 볼 권한이 없어~
404: 너가 보낸 주소 없어~
5xx : 서버쪽에 문제가 있어서 응답을 못보내주는 경우
504: 너가 요청한 작업이 너무 오래 걸려서 시간 초과가 됐어~
Response
실제로 전달하는 디테일한 정보로 json 형태로 전달된다.


JSON
요청과 응답의 형태
원래 javascript 언어에서 객체를 표현하기 위해 사용됨
데이터 타입이 아래와 같고 적은 편임 -> 모든 언어가 json 언어를 알아들을 수 있음
단점: 응답값이 100이 오면 integer 인지 short 인지 알 수 없음
string
int/float
object : { .. } -> (key, value)
array : [ ]
boolean
null

하나의 꺽쇠 = 하나의 객체 를 의미한다.
android studio에서 File 에다가 .json 확장자로 파일을 만들 수 있다.
IDE : postman(요청을 보냈을 때 응답을 받아볼 수 있는 도구)
